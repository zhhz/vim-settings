snippet note
	# NOTE (`strftime("%Y-%m-%d")`) Z => ${1}
snippet fixme
	# FIXME (`strftime("%Y-%m-%d")`) Z => ${1}
snippet todo
	# TODO (`strftime("%Y-%m-%d")`) Z => ${1}
snippet render
	render conn, ${1}
snippet ef
	Enum.filter(fn(${1}) -> ${0} end)
snippet efl
	Enum.filter(${1}, fn(${2}) -> ${0} end)
snippet em
	Enum.map(fn(${1}) -> ${0} end)
snippet eml
	Enum.map(${1}, fn(${2}) -> ${0} end)
snippet er
	Enum.reduce(${1}, fn(${2}) -> ${0} end)
snippet erf
	Enum.reduce(${1}, ${2}, fn(${3}) -> ${0} end)
snippet ej
	Enum.join
snippet ttl
	Tuple.to_list
snippet sha
	:crypto.hash(:sha, ${0})
snippet encode16
	Base.encode16
snippet slice
	String.slice(${0})
snippet join
	def join(${0}, message, socket) do
	  {:ok, socket}
	end
snippet inspect
	IO.inspect ${0}

snippet broadcast_from
	broadcast_from! socket, "${0}", message

snippet handle_in
	def handle_in(${1}, message, socket) do
		${0}
		{:reply, {:ok, message}, socket}
	end
snippet if_ok
	defmacrop if_ok(input, call) do
		quote do
			case unquote(input) do
				:conversion_error -> :conversion_error
				number -> unquote(Macro.pipe(quote(do: number), call, 0))
			end
		end
	end
snippet genserver
	defmodule ${1:Myapp.Name} do
		use GenServer
		@name ${2:module_name}

		require Logger

		def start_link(opts \\\ []) do
			GenServer.start_link(__MODULE__, :ok, opts ++ [name: $2])
		end

		def init(_) do
			Logger.info "Starting $1..."
			{:ok, %{} }
		end
	end
snippet extwitter_config
	config :ex_twitter, :oauth, [
		consumer_key: System.get_env("${1:MYAPP}_TWITTER_CONSUMER_KEY"),
		consumer_secret: System.get_env("$1_TWITTER_CONSUMER_SECRET"),
		access_token: System.get_env("$1_TWITTER_ACCESS_TOKEN"),
		access_token_secret: System.get_env("$1_TWITTER_ACCESS_SECRET")
	]
snippet handle_cast
	def handle_cast({${1}}, state) do
		${0}
		{:noreply, state}
	end
snippet spawn
	spawn fn ->
		${0}
	end
snippet spawn_link
	spawn_link fn ->
		${0}
	end
snippet do
	do
		${0:${VISUAL}}
	end
snippet put IO.puts
	IO.puts "${0}"
snippet ins IO.inspect
	IO.inspect ${0}
snippet insl IO.inspect with label
	IO.inspect(${0}label: "${1:label}")
snippet if if .. do .. end
	if ${1} do
		${0:${VISUAL}}
	end
snippet if: if .. do: ..
	if ${1:condition}, do: ${0}
snippet ife if .. do .. else .. end
	if ${1:condition} do
		${2:${VISUAL}}
	else
		${0}
	end
snippet ife: if .. do: .. else:
	if ${1:condition}, do: ${2}, else: ${0}
snippet unless unless .. do .. end
	unless ${1} do
		${0:${VISUAL}}
	end
snippet unless: unless .. do: ..
	unless ${1:condition}, do: ${0}
snippet unlesse unless .. do .. else .. end
	unless ${1:condition} do
		${2:${VISUAL}}
	else
		${0}
	end
snippet unlesse: unless .. do: .. else:
	unless ${1:condition}, do: ${2}, else: ${0}
snippet cond
	cond do
		${1} ->
		${0:${VISUAL}}
	end
snippet case
	case ${1} do
		${2} ->
			${0}
	end
snippet for
	for ${1:item} <- ${2:items} do
		${0}
	end
snippet for:
	for ${1:item} <- ${2:items}, do: ${0}
snippet fori
	for ${1:item} <- ${2:items}, into: ${3} do
		${0}
	end
snippet wi
	with ${1:item} <- ${2:items} do
		${0}
	end
snippet wie
	with(
		${1:item} <- ${2:items}
	) do
		${3}
	else
		${4} ->
			${0}
	end
snippet sp
	@spec ${1:name}(${2:args}) :: ${3:returns}
snippet op
	@opaque ${1:type_name} :: ${2:type}
snippet ty
	@type ${1:type_name} :: ${2:type}
snippet typ
	@typep ${1:type_name} :: ${2:type}
snippet cb
	@callback ${1:name}(${2:args}) :: ${3:returns}
snippet df
	def ${1:name}, do: ${2}
snippet def
	def ${1:name} do
		${0}
	end
snippet defd
	@doc """
	${1:doc string}
	"""
	def ${2:name} do
		${0}
	end
snippet defsd
	@doc """
	${1:doc string}
	"""
	@spec ${2:name} :: ${3:no_return}
	def ${2} do
		${0}
	end
snippet defim
	defimpl ${1:protocol_name}, for: ${2:data_type} do
		${0}
	end
snippet defma
	defmacro ${1:name} do
		${0}
	end
snippet defmo
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		${0}
	end
snippet dfp
	defp ${1:name}, do: ${2}
snippet defp
	defp ${1:name} do
		${0}
	end
snippet defpr
	defprotocol ${1:name}, [${0:function}]
snippet defr
	defrecord ${1:record_name}, ${0:fields}
snippet doc
	@doc """
	${0}
	"""
snippet im
	@impl true
snippet docf
	@doc false
snippet fn
	fn ${1:args} -> ${0} end
snippet mdoc
	@moduledoc """
	${0}
	"""
snippet mdocf
	@moduledoc false
snippet rec
	receive do
		${1} ->
			${0}
	end
snippet req
	require ${0:module_name}
snippet imp
	import ${0:module_name}
snippet ali
	alias ${0:module_name}
snippet test
	test "${1:test name}" do
		${0}
	end
snippet testa
	test "${1:test_name}", %{${2:arg: arg}} do
		${0}
	end
snippet des
	describe "${1:test group subject}" do
		${0}
	end
snippet exunit
	defmodule ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} do
		use ExUnit.Case, async: true

		${0}
	end
snippet try try .. rescue .. end
	try do
		${1:${VISUAL}}
	rescue
		${2} -> ${0}
	end
snippet pry
	require IEx; IEx.pry
	${0}
snippet qu
	quote do
		${1}
	end
snippet beh
	@behaviour ${1:Mix.Task}
	${0}
snippet >e pipe to each
	|> Enum.each(fn ${1} -> ${0} end)
snippet >m pipe to map
	|> Enum.map(fn ${1} -> ${0} end)
snippet >f pipe to filter
	|> Enum.filter(fn ${1} -> ${0} end)
snippet >r pipe to reduce
	|> Enum.reduce(${1:acc}, fn ${2}, ${3:acc} -> ${0} end)
snippet >i pipe to inspect
	|> IO.inspect
snippet >il pipe to inspect with label
	|> IO.inspect(label: "${1:label}")
snippet cs
	@doc false
	def child_spec(${1:_opts}) do
		%{
			id: __MODULE__,
			start: {__MODULE__, :start_link, ${2:[]}},
			restart: ${3::permanent},
			shutdown: ${4:5000},
			type: ${5::worker}
		}
	end
snippet genserver basic genserver structure
	use GenServer

	@doc false
	def start_link do
		GenServer.start_link(__MODULE__, ${1:Map.new})
	end

	@impl true
	def init(state) do
		{:ok, state}
	end
snippet genserver: basic genserver structure
	use GenServer

	@doc false
	def start_link, do: GenServer.start_link(__MODULE__, ${1:Map.new})

	@impl true
	def init(state), do: {:ok, state}
